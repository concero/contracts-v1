// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8.20;

import {Test} from "forge-std/src/Test.sol";
import {IDexSwap} from "contracts/Interfaces/IDexSwap.sol";
import {IInfraOrchestrator} from "contracts/Interfaces/IInfraOrchestrator.sol";
import {InfraOrchestrator} from "contracts/InfraOrchestrator.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {console} from "forge-std/src/console.sol";
import {DeployInfraScript} from "../scripts/DeployInfra.s.sol";
import {LibConcero} from "contracts/Libraries/LibConcero.sol";

contract DexSwapTest is Test {
    // @notice helper vars
    address internal constant NATIVE_TOKEN = address(0);
    IInfraOrchestrator.Integration internal emptyIntegration =
        IInfraOrchestrator.Integration({integrator: address(0), feeBps: 0});

    address internal infraProxy;

    modifier selectForkAndUpdateInfraProxy(uint256 forkId) {
        DeployInfraScript deployInfraScript = new DeployInfraScript();
        infraProxy = deployInfraScript.run(forkId);
        _;
    }

    function testFork_SushiSwapErc20ToErc20ViaSushiSwapApiRouting()
        public
        selectForkAndUpdateInfraProxy(vm.createFork(vm.envString("ARBITRUM_RPC_URL"), 303739014))
    {
        uint256 fromAmount = 10000000;
        uint256 toAmount = 3788629196343987;
        uint256 toAmountMin = 3788629196343987;
        address fromToken = 0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9;
        address toToken = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;
        address user = makeAddr("user");
        // @notice swap data generated by sushiswap api
        bytes
            memory dexCallData = hex"2646478b000000000000000000000000fd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb90000000000000000000000000000000000000000000000000000000000986f7000000000000000000000000082af49447d8a07e3bd95bd0d56f35241523fbab10000000000000000000000000000000000000000000000000006c386d764d334000000000000000000000000104fBc016F4bb334D775a19E8A6510109AC63E0000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000004502Fd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb901ffff00CB0E5bFa72bBb4d16AB5aA0c60601c438F04b4ad00104fBc016F4bb334D775a19E8A6510109AC63E00000bb8000000000000000000000000000000000000000000000000000000";

        IDexSwap.SwapData[] memory swapData = new IDexSwap.SwapData[](1);
        swapData[0] = IDexSwap.SwapData({
            dexRouter: vm.envAddress("SUSHISWAP_ROUTER_ARBITRUM"),
            fromToken: fromToken,
            fromAmount: fromAmount,
            toToken: toToken,
            toAmount: toAmount,
            toAmountMin: toAmountMin,
            dexCallData: dexCallData
        });
        _performSwapAndCheck(swapData, user);
    }

    /* HELPERS */

    function _performSwapAndCheck(IDexSwap.SwapData[] memory swapData, address recipient) internal {
        address fromToken = swapData[0].fromToken;
        address toToken = swapData[swapData.length - 1].toToken;
        uint256 fromAmount = swapData[0].fromAmount;
        uint256 toAmountMin = swapData[swapData.length - 1].toAmountMin;
        bool isFormTokenNative = fromToken == address(0);
        uint256 userToTokenBalanceBefore = LibConcero.getBalance(toToken, recipient);

        if (isFormTokenNative) {
            deal(recipient, fromAmount);
        } else {
            deal(fromToken, recipient, fromAmount);
        }

        vm.startPrank(recipient);
        if (isFormTokenNative) {
            InfraOrchestrator(payable(infraProxy)).swap{value: fromAmount}(
                swapData,
                recipient,
                emptyIntegration
            );
        } else {
            IERC20(fromToken).approve(address(infraProxy), fromAmount);
            InfraOrchestrator(payable(infraProxy)).swap(swapData, recipient, emptyIntegration);
        }
        vm.stopPrank();

        uint256 userToTokenBalanceAfter = LibConcero.getBalance(toToken, recipient);
        uint256 toTokenReceived = userToTokenBalanceAfter - userToTokenBalanceBefore;

        assert(toTokenReceived >= toAmountMin);
    }
}
